---
/**
 * Astro component that renders a table with search and optional filtering capabilities.
 * Uses vanilla JavaScript for client-side interactivity. Supports URL state management for search/filter params.
 *
 * @param headers: array.<{id:string, name:string, filter_by:boolean}> - header/field info.
 *   - id: must be unique in the array. must match a key in "data" object
 *   - name: field/header display name
 *   - filter_by: (optional) if true, creates a filter dropdown and enables filtering for that field.
 * @param data: array.<object> - table details. each key in the object must match a unique id in the "headers" array.
 * @param resource: (optional) string - path to JSON file with multifiltersearch data structure
 *
 * @example
 * // Using props directly:
 * <Multi
 *   headers={[
 *     { id: 'name', name: 'Name', filter_by: false },
 *     { id: 'category', name: 'Category', filter_by: true },
 *     { id: 'description', name: 'Description', filter_by: false }
 *   ]}
 *   data={[
 *     { name: 'Item 1', category: 'Type A', description: 'Description 1' },
 *     { name: 'Item 2', category: 'Type B', description: 'Description 2' }
 *   ]}
 * />
 *
 * // Using a resource file:
 * <Multi resource="data/my-data.json" />
 *
 * // JSON structure for resource file:
 * {
 *   "multifiltersearch": {
 *     "headers": [...],
 *     "data": [...]
 *   }
 * }
 * // Or simplified:
 * {
 *   "headers": [...],
 *   "data": [...]
 * }
 */

type Props = {
  resource: string;
  fm_resource: {
    headers: {
      id: string;
      name: string;
      filter_by: boolean;
    }[];
    data: Record<string, any>[];
  };
};

const { resource, fm_resource } = Astro.props;
const { pathname } = Astro.url;

// Fail early if no data source found
if (!fm_resource.headers.length && !fm_resource.data.length && !resource) {
  throw new Error(
    `No data source provided for multifiltersearch component in file: ${pathname}`
  );
}

/**
 * Get the dataset from the frontmatter or the JSON file
 * 
 */
const getDataset = async () => {
  let headers: Props["fm_resource"]["headers"] | [] = [];
  let data: Props["fm_resource"]["data"] = [];

  if (fm_resource && !resource) {
    // Get frontmatter dataset
    headers = fm_resource.headers;
    data = fm_resource.data;
  } else if (
    resource &&
    !fm_resource.headers.length &&
    !fm_resource.data.length
  ) {
    // Get JSON dataset
    const resourcePath = `../data/${resource}.json`;
    const jsonFiles = await import.meta.glob(`../data/*.json`, { eager: true });
    const jsonFile: any = Object.entries(jsonFiles).find(
      (file) => file[0] === resourcePath
    );
    if (!jsonFile) {
      throw new Error(
        `No data source found for resource param: ${resource} in file: ${pathname}`
      );
    }
    const jsonData = jsonFile[1].default;
    headers = jsonData.multifiltersearch.headers;
    data = jsonData.multifiltersearch.data;
  }
  return { headers, data };
};

const { headers, data } = await getDataset();

const state = {
  headers: headers,
  data: data,
  dropdowns: {} as Record<string, string[]>,
  filterKeys: headers.filter((header) => header.filter_by).map((header) => header.id),
  searchKeys: headers.filter((header) => !header.filter_by).map((header) => header.id),
  filterTypes: {} as Record<string, string[]>,
  searchValue: "",
  filteredSet: new Set(),
  showEmptyResultsMsg: false,
  shouldShowRecord: function (record: HTMLElement) {
    // Determines record display
    // Compares user search and filter values against lookupInfo
    const lookupInfo = record.dataset.info?.split(";"); // separate filter values from search vals
    if (!lookupInfo)
      throw new Error(`No lookup info found for record in file: ${pathname}`);
    const filterInfo = lookupInfo[0].toLowerCase().split(",");
    const searchInfo = lookupInfo.slice(1).join(" ").toLowerCase();

    // User input
    const filteredValues = Object.values(this.filterTypes);
    const searchedValues = this.searchValue.split(" ");

    // Check if record should be displayed
    const containsFilteredValues = filteredValues.every((t, idx) =>
      t.length ? t.some((f) => filterInfo[idx] === f.toLowerCase()) : true
    ); // checks filter attrs match at least one filter value. allows for multiple selection of a filter type. scrict. filter value must be a child of correct parent filter type
    const containsSearchedValues = searchedValues.every((word) =>
      searchInfo.includes(word.toLowerCase())
    ); // checks search attrs match a typed query

    if (containsSearchedValues && containsFilteredValues) {
      record.classList.add("show");
      this.filteredSet.add(record.dataset.id);
    } else {
      record.classList.remove("show");
    }

    return containsSearchedValues && containsFilteredValues;
  },
  resetFilteredSet: function () {
    // Empty filtered Set
    this.filteredSet = new Set();
  },
  deleteOneSelection: function (filterType: string, filterOption: string) {
    // delete one filterOption from selections in filter toggler
    this.filterTypes[filterType] = this.filterTypes[filterType].filter(
      (s) => s !== filterOption
    );
    this.pushState(filterType, filterOption);
  },
  deleteAllSelections: function (filterType: string) {
    // delete all selections of a filter type from filter toggler and url params

    this.filterTypes[filterType] = [];
    const url = new URL(window.location.href);

    url.searchParams.delete(filterType);
    window.history.pushState(null, "", url.toString());
  },
  initFilterSearchValues: function () {
    // Initializes and Updates x-data filter and search properties with url param values, if any

    // setup empty filterTypes object
    this.filterTypes = this.headers
      .filter((header) => header.filter_by)
      .reduce(
        (acc, header) => {
          acc[header.id] = [];
          return acc;
        },
        {} as Record<string, string[]>
      );

    // get search and filter value from url params
    const url = new URL(window.location.href);
    Array.from(url.searchParams.entries()).forEach(([key, value]) => {
      if (key === "search") {
        this.searchValue = value;
      } else {
        this.filterTypes[key]?.push(value);
      }
    });
  },
  pushState(filterType?: string, filterOption?: string) {
    // Updates url with new query params for filter type and search without refreshing the page

    const url = new URL(window.location.href);
    let newURL = "";
    if (filterType && filterOption) {
      if (!url.searchParams.getAll(filterType).includes(filterOption)) {
        // add one key:value param
        url.searchParams.append(filterType, filterOption);
      } else {
        // remove one key:value param

        function encode(match: string) {
          // callback function to encode some special characters.
          // accounting for how the toString url method encodes characters
          return match === " "
            ? "\\+"
            : "%" + match.charCodeAt(0).toString(16).toUpperCase();
        }
        const regex = new RegExp(
          `([\\&\\?])${filterType}=${filterOption.replace(/[\s()!*\[\]%,]/g, encode)}(?=\&|$)`,
          "g"
        );
        newURL = url.toString().replaceAll(regex, "").replace("/&", "/?");
      }
      if (!this.filterTypes[filterType].length) {
        url.searchParams.delete(filterType);
      }
    } else {
      url.searchParams.set("search", this.searchValue);
      if (!this.searchValue) {
        url.searchParams.delete("search");
      }
    }

    window.history.pushState(null, "", newURL || url.toString());
  },
  emptyResultsMsg () {
    // Determine and return the appropriate empty results message

    const filterValues = Object.values(this.filterTypes).flat().map(item => item.split(',')[0]).join(', ')
    if(filterValues.length && this.searchValue){
        return `No results found for query on search: '${this.searchValue}' and filter: '${filterValues}'`
    }else{
        return `No results found for query '${this.searchValue || filterValues}'`
    }
  }
};
---
<div 
is="multi-filter-search" 
class="multifilter-search-component flex flex-col" 
data-pathname={pathname}
>
    <h2>{data.length} data rows</h2>
    <!-- DATA TABLE -->
    <div class="order-1">
        <div class="table-wrapper pb-7">
        <table>
            <!-- TABLE HEADER -->
            <thead class="table-header">
            <tr>
                <!-- Range headers -->
                { headers.map(({name}) => <th>{name}</th>)}
            </tr>
            </thead>
            <tbody>
            { 
                data.map((row, idx) => {
                    // build a string with lookup info for filtering and searching against. must maintain filter_info order to align with filterTypes property.
                    const filterInfo = state.filterKeys.reduce((acc,filterKey, idx) => {
                        // Removes markdown link syntax if it exists
                        const cleanValue = row[filterKey].replace(/\[(.*)\]\(.*\)/g)
                        return `${acc}${cleanValue}${idx < state.filterKeys.length - 1 ? ',' : ''}`
                    }, '')
                    const searchInfo = state.searchKeys.reduce((acc,searchKey, idx) => {
                        // Removes markdown link syntax if it exists
                        const cleanValue = row[searchKey.toLowerCase()].replace(/\[(.*)\]\(.*\)/g)
                        return `${acc};${cleanValue}`
                    }, '')
                    const allInfo = `${filterInfo}${searchInfo}`
                    //   build object with unique values for filter dropdowns
                    //   e.g:
                    //   dropdown: {
                    //       Recommendation Category: [],
                    //       Cloud Provider: [],
                    //       Resource_Type
                    //   }
                    headers.forEach((header) => {
                        if(header.filter_by){
                            if(!state.dropdowns[header.name]){
                                state.dropdowns[header.name] = [row[header.id]]
                            }else if(state.dropdowns[header.name] && !state.dropdowns[header.name]?.includes(row[header.id])){
                                state.dropdowns[header.name].push(row[header.id])
                            }
                        }
                    })
                    return (
                        <tr 
                        data-id={idx}
                        data-info={allInfo} >
                            { headers.map(({id}) => {
                                return <td>{row[id]}</td>
                            })}
                        </tr>
                    )
                })
            }
            </tbody>
        </table>
        <!-- hook into the app lifecycle. $watch for 'filteredSet' to change and update the 'showEmptyResultsMsg' property -->
        <div>
            <!-- EMPTY MESSAGE GOES HERE Conditionally -->
        </div>
        </div>
    </div>
    
    <!-- NAV - Keep here. scratch pad for filters need to form first -->
    <nav id="multifilter-search-nav" class="w-full sticky top-[64px] self-start z-2 bg-white pt-3 pb-3 px-0">
        <div class="filters__multifilter mb-3">
            { headers.map((header, idx) => {
                return (
                    header.filter_by && (
                    <div class='filter-type mb-6' data-id={header.id} >
                        <p class="filter-type-name mb-2">{ header.name }</p>
                        <div class="filter-component">
                            <button 
                            data-id={header.id}
                            class="toggler w-full flex items-center h-10! pe-12 ps-2 rounded-lg bg-[#f6f6f6] border border-gray-300 text-left"
                            >
                                <div class="selections flex gap-x-1 overflow-scroll">
                                    {/* All */}
                                    <span class="all font-semibold ms-2">All</span>
                                    
                                    {/* { Show filter selections from `filterTypes` data in button as they are selected} */}
                                    {state.filterTypes[header.id]?.map((filter) => {
                                        return (
                                            <div class="selection-container rounded-lg flex items-center bg-[#E6D6F9] px-1">
                                                <span class="selection-name whitespace-nowrap relative -top-[1]">{filter}</span>
                                            </div>
                                        )
                                    })}
                                </div>
                                {/* { Delete all selections for a filter type } */}
                                <div class="overflow-gradient h-100 position-absolute top-0 end-0 rounded-end">
                                    {/* <template x-if="filterTypes['{{$filter_type}}'].length">
                                        <span class="cancel-circle-wrapper">
                                            icon here
                                        </span>
                                    </template> */}
                                    <span class="chevron-wrapper d-flex align-items-center justify-content-center position-relative h-100">
                                        <div class="chevron chevron-down"></div>
                                    </span>
                                </div>
                            </button>
                            {/* Filter Form */}
                            <form 
                            data-id={header.id}
                            class="hidden flex-col bg-white rounded-lg absolute w-100 max-h-545px overflow-y-scroll gap-x-3 p-2 mt-2 z-2 shadow-[0_0_1px_0_rgba(0,0,0,0.10),0_4px_16px_0_rgba(0,0,0,0.32)]"
                            >
                                <div class="filter-selection-container flex items-center ms-2">
                                    <span>All</span>
                                </div>
                                {
                                    state.dropdowns[header.name]?.map((filter) => {
                                        const cleanValue = filter.replace(/\[(.*)\]\(.*\)/g, '$1')
                                        const id = `${cleanValue}-${header.id}`
                                        return (
                                            <div class="filter-selection-container flex items-center ms-2">
                                                <input 
                                                class="w-4 h-4"
                                                type="checkbox" 
                                                id={id} 
                                                value={cleanValue}
                                                />
                                                <label for={id} class="ms-2">
                                                    {cleanValue}
                                                </label>
                                            </div>
                                        )
                                    })
                                }
                            </form>
                </div>                      
            </div>
            )
        )})}
        </div>
        <!-- //  SEARCH FORM -->
        <form class="search__multifilter">
            <input type="search" placeholder="Search here" class="w-full p-2 rounded-sm border border-gray-300">
        </form>
    </nav>
    </div>
</div>

<script>
    class MultiFilterSearch extends HTMLDivElement {
        // Customized built-in <div> Web Component. Used to encapsulate this component's code. no bleeding out
        // Note: if passing an object as data attr, you have to JSON.stringify it. you can then JSON parse it here
        pathname: string | undefined

        constructor() {
            // Always call super first in constructor
            super();
            this.pathname = this.dataset.pathname;
        }

        connectedCallback() {
            // add event listeners to toggler buttons
            const togglerBtns = this.querySelectorAll("button.toggler") as NodeListOf<HTMLElement> || null;
            togglerBtns?.forEach(btn => {
                btn.addEventListener("click", () => {
                    this.toggleFilterForm(btn);
                });
            });
            
            
        }

        /**
         * Manage filter form accordian
         * @param selectedFilterFormEl 
         */
        toggleFilterForm (selectedFilterFormEl: HTMLElement):void {
            const filterTypeID = selectedFilterFormEl.dataset.id;
            if (!filterTypeID)
            throw new Error(
                `No filter type ID found for filter form element in file: ${this.pathname}`
            );
            const togglerForm = this.querySelector(`form[data-id="${filterTypeID}"]`) as HTMLElement;
            togglerForm.classList.toggle("hidden");
            togglerForm.classList.toggle("flex");
        }




}
    // customElements.define("multi-filter-search", MultiFilterSearch, { extends: "div" });
    customElements.define("multi-filter-search", MultiFilterSearch, { extends: "div" });
</script>